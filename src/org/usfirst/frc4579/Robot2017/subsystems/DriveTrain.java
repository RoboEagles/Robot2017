// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.Robot2017.subsystems;

import org.usfirst.frc4579.Robot2017.Robot;
import org.usfirst.frc4579.Robot2017.RobotMap;
import org.usfirst.frc4579.Robot2017.commands.*;

import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController controllerLeft = RobotMap.driveTraincontrollerLeft;
    private final SpeedController controllerRight = RobotMap.driveTraincontrollerRight;
    private final RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public int drive_direction = 1;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void drive() {
    	double x = Robot.oi.joystick.getX();//*drive_direction;
    	double y = Robot.oi.joystick.getY();//*drive_direction;
    	double xsign = Math.signum(x);
    	double ysign = Math.signum(y);
    	final double slider = Robot.oi.joystick.getRawAxis(2) / 2;
    	double sensitivity = 0.5 - slider;
    	//LOGIC BUG: math.pow always returns a positive value.
    	robotDrive.arcadeDrive(Math.pow(x*sensitivity, 2)*xsign, Math.pow(y*sensitivity, 2)*ysign*drive_direction);
    	//robotDrive.arcadeDrive(Math.pow(x*sensitivity, 2)*xsign, Math.pow(y*sensitivity, 2)*ysign);
    }
    public void stop(){
    	controllerLeft.stopMotor();
    	controllerRight.stopMotor();
    }
    public void reverseDrive() {
    	System.out.println("Setting drive to reverse");
    	drive_direction = -1;
    }
    public void forwardDrive() {
    	System.out.println("Setting drive to forward");
    	drive_direction = 1;
    }
    /*
    public void findDriveSpeed() {
    	double ratio = 0.8718;
    	double initSpeed = 0.5;
    	if(Robot.measurement.realGyro() < 6.0){
    		double gyroOffset = 6.0 - Robot.measurement.realGyro();
    		initSpeed += gyroOffset/6.0;
    		Robot.driveTrain.controllerLeft.set(initSpeed);
    		Robot.driveTrain.controllerRight.set(initSpeed * ratio);
    		}else if(Robot.measurement.realGyro() > 6.0){
    			double gyroOffset = 6.0 - Robot.measurement.realGyro();
    			initSpeed += gyroOffset/6.0;
    			Robot.driveTrain.controllerLeft.set(initSpeed);
    			Robot.driveTrain.controllerRight.set(initSpeed * ratio);
    			}
    		else {
    			System.out.println(initSpeed);
    		}// this is to find overall speed start value provided ratio is correct

    }
    public void finalDriveToRight() {
    	double ratio = 0.8718;
    	double initSpeed = 0.5;//this must be known
    	if(Robot.measurement.realGyro() < 6.0){
    		double gyroOffset = 6.0 - Robot.measurement.realGyro();
    		ratio *= 1 + gyroOffset/6.0*5.198;
    		Robot.driveTrain.controllerLeft.set(initSpeed);
    		Robot.driveTrain.controllerRight.set(initSpeed * ratio);
    		}else if (Robot.measurement.realGyro() > 6.0){
    			double gyroOffset = 6.0 - Robot.measurement.realGyro();
    			ratio *= 1 + gyroOffset/6.0 * 5.198;
    			Robot.driveTrain.controllerLeft.set(initSpeed);
    			Robot.driveTrain.controllerRight.set(initSpeed * ratio);
    			}
    		
    }
    public void finalDriveToLeft() {
    	double ratio = 0.8718; 
    	double initSpeed = 0.5;//this must be known, find with first one
    	if(Robot.measurement.realGyro() < 6.0){
    		double gyroOffset = 6.0 - Robot.measurement.realGyro();
    		ratio *= 1 + gyroOffset/6.0 * 5.198;// check later for pemdas
    		Robot.driveTrain.controllerRight.set(initSpeed);
    		Robot.driveTrain.controllerLeft.set(initSpeed * ratio);
    		}else if (Robot.measurement.realGyro() > 6.0){
    			double gyroOffset = 6.0 - Robot.measurement.realGyro();
    			ratio *= 1 + gyroOffset/6.0 * 5.198;
    			Robot.driveTrain.controllerRight.set(initSpeed);
    			Robot.driveTrain.controllerLeft.set(initSpeed * ratio);
    		}

    }
    */
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DefaultDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}
